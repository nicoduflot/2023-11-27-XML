<!-- 
    L'espace de nom donne un contexte à un terme, par exemple certains mots ont plusieurs définitions, 
    c'est le contexte dans lequel on utilise ce mot qui donne sa "fonction / définition" finale

    On peut par exemple associer le document à l’espace de nom XHTML et par soucis de praticité 
    on va utiliser le préfixe html (faciliter la lecture humaine du document) 
    car il faut savoir qu’à la base le choix du préfixe est totalement arbitraire.
-->

<html:html xmlns:html="http://www.w3.org/1999/xhtml">
    <html:head>

    </html:head>
    <html:body>
        <!-- du contenu html -->
    </html:body>
</html:html>

<!-- 
    on a vu qu'il était possible de déclarer plusieurs espaces de noms pour un même document
-->

<html:html xmlns:html="http://www.w3.org/1999/xhtml"
    xmlns:mml="http://www.w3.org/1998/Math/MathML">
    <html:head>
        <html:title>Les espaces de noms</html:title>
    </html:head>
    <html:body>
        <!-- du contenu html -->
        <mml:math>
            <mml:apply>
                <mml:eq>
                    <!-- l'équation en question -->
                </mml:eq>
            </mml:apply>
        </mml:math>
    </html:body>
</html:html>

<!-- 
    on peut limiter la portée de la déclaration d'un espace de nom, 
    pour la déclaration multiple, 
    il est possible aussi de n'utilisier ( d'appeler ) un espace de nom seulement quand il est requis
-->
<!-- ici, on utilise le dialecte HTML -->
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Les espaces de noms</title>
    </head>
    <body>
        <!-- du contenu html -->
        <!-- à partir de cette balise, elle et tout ce qu'elle contyient utilise le dialect math -->
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <apply>
                <eq>
                    <!-- l'équation en question -->
                </eq>
            </apply>
        </math>
        <!-- on est "sorti" de la portée du vocabulaire math, on reviens dans le vocabulaire html -->
    </body>
</html>

<!-- 
    Mais comment faire si les balises que je doit utiliser à l'intérieur du vocabulaire HTML n'ont pas
de namespace ?
    il est en fait possible "d'annuler" un namespace de la même façon que l'on a appelé math dans un
contexte html
-->

<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Les espaces de noms</title>
    </head>
    <body>
        <!-- du contenu html -->
        <!-- à partir de cette balise, on écrit notre propre dialecte, sans vocabulaire référent -->
        <personnage xmlns="">
            <nom>Lagaffe</nom>
            <prenom>Gaston</prenom>
        </personnage>
        <!-- on est "sorti" de la portée du "pas de vocabulaire", on reviens dans le vocabulaire
        html -->
    </body>
</html>

<!-- 
XML
    http://www.w3.org/XML/1998/namespace 
XInclude
    http://www.w3.org/2001/XInclude 
XLink
    http://www.w3.org/1999/xlink 
MathML
    http://www.w3.org/1998/Math/MathML 
XHTML
    http://www.w3.org/1999/xhtml 
SVG
    http://www.w3.org/2000/svg 
Schémas
    http://www.w3.org/2001/XMLSchema 
Instances de schémas
    http://www.w3.org/2001/XMLSchema-instance 
Schematron
    http://purl.oclc.org/dsdl/schematron 
XSLT
    http://www.w3.org/1999/XSL/Transform 
XSL-FO
    http://www.w3.org/1999/XSL/Format 
DocBook
    https://tdg.docbook.org/tdg/5.1/ 
Dublin Core
    https://www.dublincore.org/specifications/dublin-core/dcmi-terms/ 


-->

<!-- 
    Les DTD : Document Type Definition

    Fichiers de définition permettant de définir une structure stricte aux documents XML

    Ce sont des règles qui permettent de définir la façon dont le document doit être écrit, 
    si des balisesdoivent absolument être présentes ou imposer le type d'un donnée.

    Quand un xml est soumis à des DTD, il faut vérifier qu'il est valide => conforme aux DTD

    Les DTDT imposent donc des normes d'écritures, utiles quand un document est écrit par 
    plusieurs personnes et pour pouvoir comprendre comment l'exploiter.

-->

<!-- DTD -->

<!-- Balise contenant une autre balise -->
<contact>
    <nom>Durand</nom>
</contact>
<!--  pour contact -->
<!ELEMENT contact (nom)>

<!-- pour nom -->
<!ELEMENT nom (#PCDATA)>

<!-- si la balise nom est vide -->
<!ELEMENT nom EMPTY>
<element /> ou
<element></element>

<!-- si la balise peut être vide ou remplie -->
<!ELEMENT nom ANY>

<element></element>
<!-- ou -->
<element>
    <balise />
</element>
<!-- ou -->
<element>texte</element>
<!-- ou -->
<element>texte<balise /></element>
<!-- ou -->
<element><balise />texte</element>

<contact>
    <nom>Durand</nom>
    <prenom>Jacques</prenom>
    <age>49</age>
</contact>
<contact>
    <nom>ACME Inc.</nom>
    <prenom></prenom>
    <age></age>
</contact>

<!ELEMENT contact (nom, prenom, age)>
<!ELEMENT nom (#PCDATA)>
<!ELEMENT prenom (#PCDATA)>
<!ELEMENT age (#PCDATA)>

<!-- ici, la balise contact DOIT avoir un e balise nom, prenom et age -->

Balise optionnelle
<!ELEMENT contact (nom, prenom?, age)>
<!-- ici, la balise contact DOIT avoir une balise nom et age, la balise prenom n'est pas
obligatoire. -->

<!-- Balise optionnelle répétée -->

<adresses>
    <adresse />
    <adresse />
    <adresse />
</adresses>

<!ELEMENT adresses (adresse*)>

<!-- Balise obligatoire qui peut être répétée plusieurs fois -->
<emails>
    <email></email> <!-- au moins une balise email obligatoire -->
    <email></email> <!-- il peut y avoir plusieurs emails -->
</emails>

<!ELEMENT emails (email+)>

<contacts>
    <contact>
        <nom>Durand</nom>
        <prenom>Jacques</prenom>
        <prenom>Antoine</prenom>
        <age>49</age>
    </contact>
    <contact>
        <nom>ACME Inc.</nom>
    </contact>
</contacts>

<!ELEMENT contacts (contact*)>
<!ELEMENT contact (nom, prenom*, age?)>
<!ELEMENT nom (#PCDATA)>
<!ELEMENT prenom (#PCDATA)>
<!ELEMENT age (#PCDATA)>

<!-- les attributs des balises en DTD -->
<!ELEMENT balise (contenu)>
<!ATTLIST balise attr>

<!-- attribut identifiant unique obligatoire -->
<contact numero="REF-001"></contact>

<!ELEMENT contact ANY>
<!ATTLIST contact numero ID #REQUIRED>

<!-- 
    Propriété de présence des attributs
    forme               signification
    #IMPLIED            Attribut facultatif
    #REQUIRED           Attribut obligatoire
    #FIXED valeur       Attribut avec cette valeur, non modifiable
    "valeur"            Attribut avec cette valeur par défaut mais modifiable
-->

<!-- attribut qui fait référence à un attribut référence de valeur unique -->
<!-- je ne fait que les parties contact et adresses -->

<!ELEMENT contact ANY>
<!ATTLIST contact personne (physique|morale) "physique">
<!ATTLIST contact numero ID #REQUIRED>
<!ELEMENT adresse ANY>
<!ATTLIST adresse type (facturation|livraison) "facturation">
<!ATTLIST adresse personne IDREF #REQUIRED>


<annuaire>
    <contacts>
        <contact personne="physique" numero="REF-001" />
        <contact personne="morale" numero="REF-002" />
        <contact personne="physique" numero="REF-003" />
    </contacts>
    <adresses>
        <adresse type="facturation" personne="REF-001" />
        <adresse type="livraison" personne="REF-001" />
        <adresse type="livraison" personne="REF-001" />
        <adresse type="facturation" personne="REF-002" />
    </adresses>
</annuaire>

<!-- IDREFS = plusieurs éléménets font référence au même ID -->
<artiste name="Korn" artisteId="K-0001" />
<artiste name="Ice Cube" artisteId="IC-0002" />
<artiste name="Incubus" artisteId="I-0003" />
<artiste name="Limp Bizkit" artisteId="LB-0004" />
<album name="Follow the leader" albumArtisteId="K-0001" />
<album name="Family values tour" albumArtisteId="K-0001 IC-0002 I-0003 LB-0004" />

<!ELEMENT artiste EMPTY>
<!ATTLIST artist name CDATA #REQUIRED>
<!ATTLIST artist artisteId ID #REQUIRED>
<!ELEMENT album EMPTY>
<!ATTLIST album name CDATA #REQUIRED>
<!ATTLIST album albumArtisteId IDREFS #IMPLIED>


<!-- 
    La valeur d'un attribut est une constante 
    La valeur de cet attribut, si renseigné, doit être de la valeur indiquée
-->
<!ELEMENT prix (#PCDATA)>
<!ATTLIST prix devise CDATA #FIXED "euro">

<!-- élément valide -->
<prix devise="euro">12</prix>
<!-- élément valide car par défaut on utilise euro -->
<prix>12</prix>
<!-- invalide car USD <=> euro -->
<prix devise="USD">12</prix>

<!-- 
    Les entités
    Se sont des alias qui permettent de réutiliser des informations dans le document xml OU dans les
DTD
        - générales
        - paramètres
        - externes
-->

<!ENTITY dacia "Dacia">
<!ENTITY renault "Renault">
<!ENTITY citroen "Citroën">

<voiture>
    <marque>&dacia;</marque>
</voiture>
<voiture>
    <marque>&renault;</marque>
</voiture>
<voiture>
    <marque>&citroen;</marque>
</voiture>

<!-- le xml doit se comprendre de la façon suivante -->

<voiture>
    <marque>Dacia</marque>
</voiture>
<voiture>
    <marque>Renault</marque>
</voiture>
<voiture>
    <marque>Citroën</marque>
</voiture>

<!-- 
    Entité paramètre
    N'apparaît QUE DANS LES DTD
    Elles associent un alias à une partie de déclaration de DTD 
    (une partie qui est souvent ré-utilisée ou très longue et qui la lecture du DTD compliquée)
-->

<voiture marque="Dacia" />
<voiture marque="Renault" />
<voiture marque="Citroën" />

<!-- DTD classique pour l'attribut marque -->
<!ATTLIST voiture marque (Dacia|Renault|Citroën) #REQUIRED>

<!-- Avec l'entité paramètre -->
<!ENTITY % listeMarques "marque (Dacia|Renault|Citroën) #REQUIRED">
<!ATTLIST voiture %listeMarques>

<!-- autre exemple -->
<!ELEMENT contact (nom?, prenom?, login)>
<!ELEMENT personnage (nom?, prenom?, role)>

<!-- avec les entités paramètres -->
<!ENTITY % identite "nom?, prenom?">
<!ELEMENT contact (%identite, login)>
<!ELEMENT personnage (%identite, role)>

<!-- 
    Les entités externes
    Permettent de faire référence, comme les entités générales, à des information a utiliser dans le
document xml,
    mais elles sont écritent dans un ficher externe
-->

<!-- déclaration des entités externe -->
<!ENTITY dacia SYSTEM "dacia.xml">
<!ENTITY renault SYSTEM "renault.xml">
<!ENTITY citroen SYSTEM "citroen.xml">

<!-- utilisation des entités externes dans le xml -->
<voiture>
    %dacia;
</voiture>
<voiture>
    %renault;
</voiture>
<voiture>
    %citroen;
</voiture>

<!-- dacia.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE description [
    <!ELEMENT description (marque, modele, portes)>
    <!ELEMENT marque (#PCDATA)>
    <!ELEMENT modele (#PCDATA)>
    <!ELEMENT portes (#PCDATA)>
]>
<description>
    <marque>
        Dacia
    </marque>
    <modele>
        Sandero
    </modele>
    <portes>
        5
    </portes>
</description>

<!-- 
    Autre schéma de validation XML : XSD (Xml Schema Definition)
    Pourquoi ?
    1 - Les DTD ne sont pas au format XML, c'est un autre language avec sa propre syntaxe et ses
règles/
        => Il faut l'utiliser avec XML et il se peut que certaines API vont lire le XML et le DTD
différemment.
    2 - On ne peut pas typer les données en DTD (typer une donnée : dire que la donnée dans l'attribut
ou l'élément correspond à un type,
        ex :    12 => entier
                12.5 => nombre à virgule flottante
                toto => chaîne de caractère
    
    Les xsd permet de typer les données, il est aussi plus précis sur l'écriture de contraintes 
    (présence d'un élément ou d'un attribut, séquence d'élément, ordre précis ou non d'éléments dans
une balise, etc)

    Il s'écrit en xml, il se stocke dans un fichier externe avec l'extension .xsd, et il utilise comme
les fichiers.xml 
    un prologue dont le nom de l'élément racine est imposé
-->

<!-- prologue et déclaration d'un élément racine .xsd -->
<?xml version="1.0" encoding="UTF-8"?>
<!-- déclaration de l'élément racine imposé du xsd-->
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    <!-- le schéma xsd du document -->
</xsd:schema>

<!-- ici on a déclaré un espace de nom pour le schéma (xsd) donc tous les éléments seront préfixé
xsd: -->

<!-- le fichier xml qui va utiliser le xsd peut appeler les xsd avec ou sans espace -->

<!-- fichier xml utilisant un xsd ne décrivant pas d'espace de nom -->
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<agenda xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="agenda.xsd">
    <!-- on crée un ns pour pourvoir appeler un schéma qui va définir tout l'agenda -->
    <rolodex>
        <nom>Durant</nom>
    </rolodex>
    <garage>
        <voiture>
            <marque>Opel</marque>
        </voiture>
    </garage>
</agenda>

<!-- fichier xml utilisant un xsd décrivant un espace de nom -->
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<agenda
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="urn:Rolodex rolodex.xsd"
    xsi:schemaLocation="urn:Garage garage.xsd">
    <!-- on crée un ns pour pourvoir appeler plusieurs schémas pour décrire différentes partie de
    l'agenda -->
    <Rolodex:rolodex>
        <Rolodex:nom>Durant</Rolodex:nom>
    </Rolodex:rolodex>
    <Garage:garage>
        <Garage:voiture>
            <Garage:marque>Opel</Garage:marque>
        </Garage:voiture>
    </Garage:garage>
</agenda>

<!-- 
    le fichier au dessus a récupéré à la fois 
        - les données de rolodex, dont le schéma est défini dans rolodex.xsd  
        - les données de garage, , dont le schéma est défini dans garage.xsd 

    on a donc besoin dans le xml d'un namespace de schéma pour associer 
    les différentes parties du xml aux schémas de vérification de chaque partie
-->

<!-- 
    en dessous, pour chaque xml (rolodex et garage) on extrait chaque partie à part, 
    chacune ayant son xsd, donc pas besoin de décrire un espace de nom pour 
    le xsd a appliquer à chaque partie 
-->
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<agenda
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="rolodex.xsd">
    <!-- on crée un ns pour pourvoir appeler plusieurs schémas pour décrire différentes partie de
    l'agenda -->
    <rolodex>
        <nom>Durant</nom>
    </rolodex>
</agenda>
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<agenda
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:noNamespaceSchemaLocation="garage.xsd">
    <!-- on crée un ns pour pourvoir appeler plusieurs schémas pour décrire différentes partie de
    l'agenda -->
    <garage>
        <voiture>
            <marque>Opel</marque>
        </voiture>
    </garage>
</agenda>

<!-- 
    Déclaration des éléments en xsd 

    Élément simple : 
    une balise, sans attribut, ne contenant pas d'autres balises, dont le type de donnée contenu est
simple.

    Élément complexe :
    une balise qui contient d'autres balises, ou dont le type de donnée contenu est complexe, ou qui
possède au moins un attribut.
-->

<!-- ni attribut, nit élément, type de donnée simple => élément simple -->
<nom>Durand</nom>

<!-- Contient un attribut mais type de donnée simple : élément complexe -->
<personne type="physique">Jean Durand</personne>

<!-- contient d'autres balises -->
<!-- personne : élément complexe -->
<personne type="physique">
    <!-- nom et prenom : éléments simples -->
    <nom>Durand</nom>
    <prenom>Jean</prenom>
</personne>

<!-- 
    Déclarer un élément simple
    <namespace:element (avec le namespace définit pour le schéma) name="nom de l'élément" type="le type
de la donnée contenue dans l'élément" />
    <xsd:element name="" type="" />
-->
<nom>Durand</nom>
<prenom>Jean</prenom>
<age>43</age>

<!-- en xsd -->
<xsd:element name="nom" type="xsd:string" />
<xsd:element name="prenom" type="xsd:string" />
<xsd:element name="age" type="xsd:integer" />

<!-- 
    Quelques types simple et leur définitions
    xsd:string  : chaîne de caractère "monsieur untel" "2d" "205"
    xsd:decimal : nombre à virgule flottante "12.5" "3.14168"
    xsd:integer : nombre entier "-2" "0" "12" "65535"
    xsd:boolean : booléen => vrai ou faux true or false
    xsd:date    : une date AAAA-MM-JJ ex 2023-11-28
    xsd:time    : une heure hh:mm:ss ex 13:55:22
-->

<!-- mettre une valeur par défaut -->
<xsd:element name="nom" type="xsd:string" default="Doe" />
<xsd:element name="prenom" type="xsd:string" default="John" />
<xsd:element name="age" type="xsd:integer" />

<!-- exemple de xml validés par ce schéma -->
<!-- validé -->
<nom>Durand</nom>
<prenom>Jean</prenom>
<age>43</age>

<!-- validé -->
<nom></nom> <!-- valeur par défaut "Doe" -->
<prenom>Jean</prenom>
<age>43</age>

<!-- validé -->
<nom>Durand</nom>
<prenom></prenom> <!-- valeur par défaut "John" -->
<age>43</age>

<!-- validé -->
<nom></nom> <!-- valeur par défaut "Doe" -->
<prenom></prenom> <!-- valeur par défaut "John" -->
<age>43</age>
<!-- valide -->
<nom></nom> <!-- valeur par défaut "Doe" -->
<prenom></prenom> <!-- valeur par défaut "John" -->
<age></age> <!-- pas de valeur par défaut, mais comme il n'est pas indiqué comme obligatoire, le xml
est valide -->

<!--
    Valeur constante 
    valeur inchangeable, imposée et non valide si la balise est vide
-->

<xsd:element name="status" type="xsd:string" fixed="Employé·e" />
<!-- valide -->
<status>Employé·e</status>
<!-- invalide car donnée <=> Employé·e-->
<status>Junior</status>
<!-- invalide car donnée vide -->
<status></status>

<!-- 
    Les attributs

    Se sont par essence des éléments simple, pour les déclarer le mot clef c'est attribute
    <xsd:attribute  name="nom de l'attribut" type="type de l'attribut" />
 -->

<personne type="physique"></personne>

<!-- attribut type :  -->
<xsd:attribute name="type" type="xsd:string" />

<!-- ATTENTION, on déclare normalement cet attribut dans la déclaration de l'élement qui le
contient, qui est lui un élément complexe -->

<!-- valeur par défaut, constante, et obligatoire -->
<!-- par défault -->
<xsd:attribute name="type" type="xsd:string" default="physique" />

<!-- constante -->
<!-- attribut devise -->
<xsd:attribute name="devise" type="xsd:string" fixed="euro" />

<!-- valide -->
<prix devise="euro">12.5</prix>

<!-- valide -->
<prix devise="">12.5</prix>

<!-- invalide -->
<prix devise="USD">12.5</prix>

<!-- obligatoire -->
<xsd:attribute name="devise" type="xsd:string" use="required" />


<!-- Quelques exemple d'éléments et d'attributs avec des types différents -->
<!-- string : chaîne de caractère -->
<xsd:element name="string" type="xsd:string" />
<string>Karamasov</string>
<string>Une phrase choc</string>
<!-- 
    certains caractère spéciaux doivent être écrit avec leur notation HTML 
    & devra s'écrire en donnée &amp;
-->
<string>Tintin &amp; Milou "Les copains" &lt;toto&gt; </string>
<!-- '&' => &amp; '<' => &lt; '>' => &gt;  -->

<string>toto</string>
<string>
    toto,
    c'est le meilleur
</string>

<!-- language -->
<xsd:element name="langue" type="xsd:language" />
<!-- 
    norme de l'écriture d'un type language
    les deux lettres du code langue basé sur la norme ISO 639
    peut être complété par les deux lettre du code pays selon la norme ISO 3166
    xx (code langue en minsucule)
    xx-YY (YY :  code pays en majuscule)
 -->

<langue>fr-CA</langue>
<langue>fr-FR</langue>
<langue>en</langue>
<langue>en-US</langue>
<langue>en-GB</langue>
<langue>en-CA</langue>

<!-- 
    nmtoken string sans espace au début et à la fin, sans tabulation, sans retour chariot, sans saut de
ligne
    caractères spéciaux acceptés : 
        . - _ et :
    utilisé uniquement pour les attributs
-->
<xsd:attribute name="myToken" type="xsd:NMTOKEN" />
<balise myToken="A:B_b-2.3">Contenu de ma balise</balise>
<balise myToken="AZERTY">Contenu de ma balise</balise>
<balise myToken="123456">Contenu de ma balise</balise>

<!-- invalide : il y a un espace après le dernier caracrtère de la valeur de l'attribut <> type
nmtoken -->
<balise myToken="123456 ">Contenu de ma balise</balise>

<!-- 
    nmtokens : liste de nmtoken, séparés par un espace, même caractères spéciaux acceptés que nmtoken 
    et uniquement utilisable dans les attributs
 -->

<xsd:attribute name="myTokens" type="xsd:NMTOKENS" />
<balise myTokens="A:B_b-2.3">Contenu de ma balise</balise>
<balise myTokens="A:B_b-2.3 AZERTY">Contenu de ma balise</balise>
<balise myTokens="AZERTY 123456">Contenu de ma balise</balise>
<balise myTokens="A:B_b-2.3 AZERTY 123456">Contenu de ma balise</balise>

<!-- invalide : il y a un espace avant le premier caracrtère de la valeur de l'attribut <> type
nmtokens -->
<balise myTokens=" AZERTY 123456">Contenu de ma balise</balise>

<!-- ID et IDREF -->
<xsd:attribute name="num" type="xsd:ID" />
<xsd:attribute name="parent" type="xsd:IDREF" />
<personne num="P1">Paul</personne>
<personne num="P2">JP</personne>
<personne num="P3" parent="P1">Martin</personne>
<personne num="P4" parent="P2">Camille</personne>

<!-- ID et IDREFS -->

<xsd:attribute name="num" type="xsd:ID" />
<xsd:attribute name="parents" type="xsd:IDREFS" />
<personne num="P1" parents="">Paul</personne>
<personne num="P2" parents="">JP</personne>
<personne num="P3" parents="">Marie</personne>
<personne num="P4" parents="">Julie</personne>

<personne num="P5" parents="P1 P3">Martin</personne>
<personne num="P6" parents="P1 P3">Camille</personne>
<personne num="P7" parents="P2 P4">Zélie</personne>
<personne num="P8" parents="P2 P4">Abraham</personne>

<!--
    Entity
    Entity permet de référencer des éléments entités, souvent non xml, qui sont déclarés dans des dtd
(soit fichier.dtd soit doctype dtd directement dans le fichier xml)
    Ne s'utilise que dans les attributs
 -->

<!-- .xsd -->
<xsd:attribute name="marque" type="xsd:ENTITY" />
<!-- .dtd -->
<!ENTITY samsung "Samsung">
<!ENTITY apple "Apple">
<!-- .xml -->
<telephone marque="samsung">Galaxy SII
</samsung>
<telephone marque="apple">Iphone 254
</samsung>

<!-- ENTITIES -->
<!-- .xsd -->
<xsd:attribute name="marque" type="xsd:ENTITIES" />
<!-- .dtd -->
<!ENTITY samsung "Samsung">
<!ENTITY apple "Apple">
<!-- .xml -->
<telephone marque="samsung apple" />

<!-- Les éléments et les types complexes -->
<!-- personne : élément complexe (il contient d'autres balises) -->
<personne>
    <!-- élément simple -->
    <nom>Robert</nom>
    <!-- élément simple -->
    <prenom>Axel</prenom>
</personne>

<!-- personne : élément complexe contient au moins un attribut -->
<personne type="physique">Axel Robert</personne>

<!-- balise est un élément complexe : contient d'autres balises et au moins un attribut -->
<balise attr="test">
    <!--  contient d'autres balises -->
</balise>

<!-- pour déclarer un élément complexe -->
<xsd:element name="personne">
<xsd:complexeType>
    <!-- description du complexeType attrobuts s'il y en a de personne et déclarations des balises à
    l'intérieur s'il y en a -->
</xsd:complexeType>
</xsd:personne>

<!-- 
    Élements complexes avec du contenu simple
  -->

<prix devise="euro">5600</prix>

<!-- élément prix -->
<xsd:element name="prix">
    <!-- indiquer que l'élément est de type complexe -->
    <xsd:complexeType>
        <!-- préciser que son contenu est simple -->
        <xsd:simpleContent>
            <!-- déclarer le contenu simple de la balise (ici le type du contenu) -->
            <xsd:extension base="xsd:positiveInteger">
                <xsd:attribute name="devise" type="xsd:string" />
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexeType>
</xsd:element>

<voiture marque="Renault" moteur="essence">Clio</voiture>

<!-- élément voiture -->
<xsd:element name="voiture">
    <!-- indiquer que l'élément est de type complexe -->
    <xsd:complexeType>
        <!-- préciser que son contenu est simple -->
        <xsd:simpleContent>
            <!-- déclarer le contenu simple de la balise (ici le type du contenu) -->
            <xsd:extension base="xsd:string">
                <xsd:attribute name="marque" type="xsd:string" />
                <xsd:attribute name="moteur" type="xsd:string" />
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexeType>
</xsd:element>

<!-- balise qui contient d'autres balises -->
<personne type="physique">
    <prenom>Axel</prenom>
    <nom>Robert</nom>
</personne>

<xsd:element name="personne">
<xsd:complexeType>
    <!-- ATTENTION : sequence implique que l'ordre des balises dans le XML doit être dans le même
    ordre dans la déclaration -->
    <xsd:sequence>
        <xsd:element name="prenom" type="xsd:string" />
        <xsd:element name="nom" type="xsd:string" />
    </xsd:sequence>
    <xsd:attribute name="type" type="xsd:string" />
</xsd:complexeType>
</xsd:personne>

<!-- si on utilise all à la place de sequence, il est possible de déclarer les balise dans n'importe
quel ordre  -->
<xsd:element name="personne">
<xsd:complexeType>
    <xsd:all>
        <xsd:element name="nom" type="xsd:string" />
        <xsd:element name="prenom" type="xsd:string" />
    </xsd:all>
    <xsd:attribute name="type" type="xsd:string" />
</xsd:complexeType>
</xsd:personne>

<!-- dans les cas précédents, les balise déclarées doivent être présentent dans le xml -->
<!-- en utilisant choice au lieu de sequence ou all, les balises déclarées dans ce choix deviennent
facultative -->
<xsd:element name="personne">
<xsd:complexeType>
    <xsd:choice>
        <xsd:element name="nom" type="xsd:string" />
        <xsd:element name="prenom" type="xsd:string" />
    </xsd:choice>
    <xsd:attribute name="type" type="xsd:string" />
</xsd:complexeType>
</xsd:personne>

<!-- avec choice, tous les format xml suivants sont valides -->

<personne type="physique">
    <prenom>Axel</prenom>
    <nom>Robert</nom>
</personne>

<personne type="physique">
    <prenom>Axel</prenom>
</personne>

<personne type="physique">
    <nom>Robert</nom>
</personne>

<personne type="physique"></personne>

<!-- un type complexe dans un type complexe -->
<personne>
    <identite>
        <nom>Vance</nom>
        <prenom>Jack</prenom>
    </identite>
</personne>

<xsd:element name="personne">
    <xsd:complexeType>
        <xsd:sequence>
            <xsd:element name="identite">
                <xsd:complexeType>
                    <xsd:sequence>
                        <xsd:element name="nom" type="xsd:string" />
                        <xsd:element name="prenom" type="xsd:string" />
                    </xsd:sequence>
                </xsd:complexeType>
            </xsd:element>
        </xsd:sequence>
    </xsd:complexeType>
</xsd:element>

<!-- contenu mixte -->
<description> Une console de <b>80</b>x<b>120</b> cm, <prix>200</prix> euro </description>


<facture> L'acheteur <acheteur>Brendan L. Mulligan</acheteur>, doit payer la somme de <somme>1000</somme>
    euros </facture>
<!-- facture -->
<xsd:element name="facture">
    <xsd:complexeType mixed="true">
        <xsd:sequence>
            <xsd:element name="acheteur" type="xsd:string" />
            <xsd:element name="somme" type="xsd:float" />
        </xsd:sequence>
    </xsd:complexeType>
</xsd:element>

<!-- les occurences d'un élément -->
<personne type="physique">
    <nom>Robert</nom>
    <prenom>Axel</prenom>
    <prenom>Patrice</prenom>
    <prenom>Maurice</prenom>
    <prenom>Marcel</prenom>
</personne>

<xsd:element name="personne">
<xsd:complexeType>
    <xsd:sequence>
        <xsd:element name="nom" type="xsd:string" />
        <xsd:element name="prenom" type="xsd:string"
            minOccurs="1"
            maxOccurs="4" />
    </xsd:sequence>
    <xsd:attribute name="type" type="xsd:string" />
</xsd:complexeType>
</xsd:personne>

<!-- de 0 à X occurences -->

<xsd:element name="personne">
<xsd:complexeType>
    <xsd:sequence>
        <xsd:element name="nom" type="xsd:string" />
        <xsd:element name="prenom" type="xsd:string"
            minOccurs="0"
            maxOccurs="unbounded" />
    </xsd:sequence>
    <xsd:attribute name="type" type="xsd:string" />
</xsd:complexeType>
</xsd:personne>

<!-- 
    Réutilisation des types et des élément : Simplifier l'écriture et la lecture des xsd
-->

<banque>
    <!-- 1er client -->
    <client>
        <identite>
            <nom>Adams</nom>
            <prenom>Douglas</prenom>
            <adresse>
                <numero>21</numero>
                <voie>Baker Street</voie>
                <codepostal>W1U 8ED</codepostal>
                <ville>Londre</ville>
                <pays codelang="en-GB">Angleterre</pays>
            </adresse>
        </identite>
        <comptes>
            <compteInterets interets="1.5" nom="Livret A">
                <montant>2500</montant>
            </compteInterets>
            <compteInterets interets="1.2" nom="LEP">
                <montant>23500</montant>
            </compteInterets>
            <compte>
                <montant>4200</montant>
            </compte>
        </comptes>
    </client>
</banque>
<?xml version="1.0" encoding="UTF-8"?>
<!-- définir le schéma du xsd -->
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    <!-- élément banque -->
    <xsd:element name="banque">
        <xsd:complexType>
            <xsd:sequence>
                <!-- element client -->
                <xsd:element name="client" minOccurs="0" maxOccurs="unbounded">
                    <xsd:complexType>
                        <xsd:sequence>
                            <!-- identité -->
                            <xsd:element name="identite">
                                <xsd:complexType>
                                    <xsd:sequence>
                                        <!-- elements nom, prenom -->
                                        <xsd:element name="nom" type="xsd:string" />
                                        <xsd:element name="prenom" type="xsd:string" />
                                        <!-- elements adresse-->
                                        <xsd:element name="adresse">
                                            <xsd:complexType>
                                                <xsd:sequence>
                                                    <!-- elements nimero, voie, codepostal, ville,
                                                    pays -->
                                                    <xsd:element name="numero" type="xsd:string" />
                                                    <xsd:element name="voie" type="xsd:string" />
                                                    <xsd:element name="codepostal" type="xsd:string" />
                                                    <xsd:element name="ville" type="xsd:string" />
                                                    <!-- element complexe pays -->
                                                    <xsd:element name="pays">
                                                        <xsd:complexType>
                                                            <xsd:simpleContent>
                                                                <xsd:extension base="xsd:string">
                                                                    <xsd:attribute name="codelang"
                                                                        type="xsd:string" />
                                                                </xsd:extension>
                                                            </xsd:simpleContent>
                                                        </xsd:complexType>
                                                    </xsd:element>
                                                </xsd:sequence>
                                            </xsd:complexType>
                                        </xsd:element>
                                    </xsd:sequence>
                                </xsd:complexType>
                            </xsd:element>
                            <!-- comptes -->
                            <xsd:element name="comptes">
                                <xsd:complexType>
                                    <xsd:sequence>
                                        <!-- compteInterets -->
                                        <xsd:element
                                            name="compteInterets"
                                            minOccurs="0"
                                            maxOccurs="unbounded">
                                            <xsd:complexType>
                                                <xsd:attribute name="interets" type="xsd:float" />
                                                <xsd:attribute name="nom" type="xsd:string" />
                                                <xsd:sequence>
                                                    <!-- montant -->
                                                    <xsd:element name="montant" type="xsd:float" />
                                                </xsd:sequence>
                                            </xsd:complexType>
                                        </xsd:element>
                                        <!-- compte -->
                                        <xsd:element name="compte">
                                            <xsd:complexType>
                                                <xsd:sequence>
                                                    <!-- montant -->
                                                    <xsd:element name="montant" type="xsd:float" />
                                                </xsd:sequence>
                                            </xsd:complexType>
                                        </xsd:element>
                                    </xsd:sequence>
                                </xsd:complexType>
                            </xsd:element>
                        </xsd:sequence>
                    </xsd:complexType>
                </xsd:element>
            </xsd:sequence>
        </xsd:complexType>
    </xsd:element>
</xsd:schema>

<!-- 
    Les xsd deviennent très difficiles à lire (et a écrire !), 
    il est possible (recommandé) de les découper en parties réutilisables,
    pour les rendre plus facile a écrire et a lire
    le mot-clef : ref
-->
<?xml version="1.0" encoding="UTF-8"?>
<!-- définir le schéma du xsd -->

<!-- déclaration des éléments simples -->
<xsd:element name="nom" type="xsd:string" />
<xsd:element name="prenom" type="xsd:string" />
<xsd:element name="numero" type="xsd:string" />
<xsd:element name="voie" type="xsd:string" />
<xsd:element name="codepostal" type="xsd:string" />
<xsd:element name="ville" type="xsd:string" />
<!-- déclaration de l'élément complexe pays -->
<xsd:element name="pays">
    <xsd:complexType>
        <xsd:simpleContent>
            <xsd:extension base="xsd:string">
                <xsd:attribute name="codelang" type="xsd:string" />
            </xsd:extension>
        </xsd:simpleContent>
    </xsd:complexType>
</xsd:element>
<!-- déclaration de l'élément simple montant -->
<xsd:element name="montant" type="float" />

<!-- les éléments composant adresse sont tous des éléments simple, je peux les regrouper -->

<xsd:group name="grp-adresse">
    <xsd:sequence>
        <xsd:element ref="numero" />
        <xsd:element ref="voie" />
        <xsd:element ref="codepostal" />
        <xsd:element ref="ville" />
        <xsd:element ref="pays" />
    </xsd:sequence>
</xsd:group>

<!-- création de l'élément adresse -->
<xsd:element name="adresse">
    <xsd:complexType>
        <xsd:group ref="grp-adresse" />
    </xsd:complexType>
</xsd:element>

<!-- créer le groupe identite -->
<xsd:group name="grp-identite">
    <xsd:sequence>
        <xsd:element ref="nom" />
        <xsd:element ref="prenom" />
        <xsd:element ref="adresse" />
    </xsd:sequence>
</xsd:group>

<!-- créer l'élément identité -->
<xsd:element name="identite">
    <xsd:complexType>
        <xsd:group ref="grp-identite" />
    </xsd:complexType>
</xsd:element>

<!-- 
    On peut créer ses propres types (on le fait déjà quand on déclare complexType pour un élément).
    Ici, compte et compte intérets ont le même format (une balise compte qui contient une balise
montant)

    Comment déclarer sont propre type ?

    Déclarer un élément avec son propre type simple
    ________________________________________
    <xsd:simpleType name="mon_type_perso">
        <xsd:restriction base="mon_type_perso">
            ....
        </xsd:restriction>
    </xsd:simpleType>


    utilisation du type simple :
    ________________________________________

    <xsd:element name="balise" type="mon_type_perso" />

    déclaration d'un type complexe
    __________________________________

    <xsd:complexType name="mon_type_complexe">

    </xsd:complexType>

    utilisation du type complexe
    __________________________________

    <xsd:element name="mon_element_type_complexe" type="mon_type_complexe" />

-->

<!-- déclaration du type compteCourant -->
<xsd:complexeType name="compteCourant">
    <xsd:sequence>
        <xsd:element ref="montant" />
    </xsd:sequence>
</xsd:complexeType>

<!-- déclaration du type compteInteret -->
<xsd:complexeType name="compteInteret">
    <xsd:complexContent>
        <xsd:extension base="compteCourant">
            <xsd:attribute name="interets" type="xsd:float" />
            <xsd:attribute name="nom" type="xsd:string" />
        </xsd:extension>
    </xsd:complexContent>
</xsd:complexeType>

<!-- 
    ici, compteInteret est une extension du type compte, 
    c'est à dire que je n'ai pas besoin de redéclarer sont contenu qui est la balise montant, 
    en revanche, j'ajoute au type de base les attributs définissant le compteInteret

    on aurait pu déclarer le type conteInteret de cette façon

    <xsd:complexeType name="compteInteret">
        <xsd:attribute name="interets" type="xsd:float" />
        <xsd:attribute name="nom" type="xsd:string" />
        <xsd:sequence>
            <xsd:element ref="montant" />
        </xsd:sequence>
    </xsd:complexeType>

-->

<!-- création de la partie comptes -->
<xsd:element name="comptes">
    <xsd:complexType>
        <xsd:sequence>
            <xsd:element name="compteInterets" type="compteInteret" minOccurs="0"
                maxOccurs="unbounded" />
            <xsd:element name="compte" type="compteCourant" />
        </xsd:sequence>
    </xsd:complexType>
</xsd:element>

<!-- création de l'élément client -->
<xsd:element name="client">
    <xsd:complexType>
        <xsd:sequence>
            <xsd:element ref="identite" />
            <xsd:element ref="comptes" />
        </xsd:sequence>
    </xsd:complexType>
</xsd:element>

<!-- schéma final du xsd -->
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    <xsd:element name="banque">
        <xsd:complexType>
            <xsd:sequence>
                <xsd:element ref="client" minOccurs="0" maxOccurs="unbounded" />
            </xsd:sequence>
        </xsd:complexType>
    </xsd:element>
</xsd:schema>

<!-- 
    Créer ses types : deux façons 

    - par restriction
    - par extension (compteCourant et compteInteret)
-->

<!-- 
    Héritage par restriction
-->

<!-- pour un élément -->
<xsd:element name="mon_nom">
    <xsd:simpleType>
        <xsd:restriction base="type_de_base">
            <!-- type_de_base peut être : float, string, etc. -->
            <!-- détails de la restriction -->
        </xsd:restriction>
    </xsd:simpleType>
</xsd:element>

<!-- pour un attribut -->
<xsd:attribute name="mon_nom">
    <xsd:simpleType>
        <xsd:restriction base="type_de_base">
            <!-- type_de_base peut être : float, string, etc. -->
            <!-- détails de la restriction -->
        </xsd:restriction>
    </xsd:simpleType>
</xsd:attribute>

</xsd:element></xsd:element></xsd:element></xsd:element></xsd:element></xsd:element>

<!-- exemple sur un attribut -->
<!-- 
    une balise personne qui possède un attribut age, 
    dont la valeur doit être strictement supérieur à 17,
    et strictement inférieur à 80

    ]17, 80[ 17 et 80 exclus        minExclusive="17" maxExclusive="80"     <= le cas décris pour notre balise
    [17, 80] 17 inclu, 80 inclu     minInclusive="17" maxInclusive="80"
    ]17, 80] 17 exclu, 80 inclu     minExclusive="17" maxInclusive="80"
    [17, 80[ 17 inclu, 80 exclu     minInclusive="17" maxExclusive="80"

-->
<!-- invalide age = 17 -->
<personne age="17" />
<!-- valide, 17 < age < 80 -->
<personne age="18" />
<!-- valide, 17 < age < 80 -->
<personne age="43" />
<!-- invalide age = 80 -->
<personne age="80" />
<xsd:element name="personne">
    <xsd:complexType>
        <!-- déclaration de l'attribut -->
        <xsd:attribute>
            <xsd:simpleType>
                <xsd:restriction base="xsd:nonNegativeInteger">
                    <xsd:minExclusive value="17" />
                    <xsd:maxExclusive value="80" />
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:attribute>
    </xsd:complexType>
</xsd:element>

<!-- 
    Les restrictions s'appliquent de la même manière pour
    1 valeurs numériques
    minExclusive    : valeur min exclue
    minInclusive    : valeur min inclue
    maxExclusive    : valeur max exclue
    maxInclusive    : valeur max inclue
    totalDigits     : le nombre exact de chiffres qui composent un nombre
    fractionDigits  : le nombre exact de chiffres après la virgule

    2 valeurs sur les chaînes de caractères
    length          le nombre exact de caractères dans une chaîne de caractère
    minLength       le nombre minimum de caractères dans une chaîne de caractère
    maxLength       le nombre maximum de caractères dans une chaîne de caractère
-->

<!-- enumeration : liste des valeurs possibles pour un élément ou un attribut -->
<!-- valide -->
<personne type="physique">
    <nom>Duflot</nom>
</personne>

<!-- valide -->
<personne type="Morale">
    <nom>Globo Inc.</nom>
</personne>

<!-- invalide -->
<personne type="truc">
    <nom>Bla !</nom>
</personne>

<xsd:element name="personne">
    <xsd:complexType>
        <!-- déclaration élément nom -->
        <xsd:element name="nom" type="xsd:string" />
        <!-- déclaration de l'attribut type avec la restriction sur les données qu'il peut contenir -->
        <xsd:attribute name="type">
            <xsd:simpleType>
                <xsd:restriction base="xsd:string">
                    <xsd:enumeration value="physique" />
                    <xsd:enumeration value="morale" />
                </xsd:restriction>
            </xsd:simpleType>
        </xsd:attribute>
    </xsd:complexType>
</xsd:element>

<!-- reçu -->
<nom>Gérard     Manfroi
    
</nom>
<!-- interprété / lu -->
<nom>Gérard Manfroi </nom>

<!--
    restriction sur les "espaces" dans les données à l'intérieur des élément ou des attributs
    (tabulation, retour à la ligne, espaces simple en plusieurs fois

    la restriction whiteSpace 

    preserve    : garder la donnée telle qu'elle est reçue
    replace     : remplace tous les espaces par des espaces simples (si il ya à la fois une tabulation, un retour chariot et un espace simple => 3 espaces simples)
    collapse    : remplace tous les espaces par un espace simple (si il ya à la fois une tabulation, un retour chariot et un espace simple => 1 espace simple)

-->

<xsd:element name="nom">
    <xsd:simpleType>
        <xsd:restriction base="xsd:string">
            <xsd:whiteSpace value="collapse" />
        </xsd:restriction>
    </xsd:simpleType>
</xsd:element>

<!--  
    Pattern 
    détermine un modèle de chaîne de caractère pour vérifier si une chaîne est bien dans un format normé
    par exemple, un email devra avoir une série de caractère, un arobase, un série de caractère, et au moins un point suivi d'une série de caractère
    mot@entreprise.domaine  => bon
    @entreprise.domaine     => mauvais
    mot@.domaine            => mauvais
    etc.

    il existe différente version pour ce modèle, celui qu'on utilisera : ^[\w-\.]+@([\w-]+\.)+[\w-]{2,12}$
    
-->
<!-- valide -->
<email>nduflot@dawan.fr</email>

<!-- invalide -->
<email>@toto.com</email>

<xsd:element name="email">
    <xsd:simpleType>
        <xsd:restriction base="xsd:string">
            <xsd:maxLength value="254" />
            <xsd:pattern value="^[\w-\.]+@([\w-]+\.)+[\w-]{2,12}$" />
        </xsd:restriction>
    </xsd:simpleType>
</xsd:element>

<!--
    Équivalent en xsd de ID IDREF (DTD)
    
    key et keyref
    permet d'identifier et de référencer les ressources dans un schéma XML en étant plus précis que ID et IDREF
 -->

 <!-- 
    key
    un élément composé d'un selector en utilisant la syntaxe xpath 
    xpath est le chmein (relatif ou abolu) des éléments dans l'arbre XML
 -->

 <!-- création d'une clef -->
 <xsd:key name="nom_unique_de_la_clef">
    <xsd:selector xpath="expression xpath utlisée pour l'élément déclaré en clef" />
    <!-- une fois la clef déclarée, il faut identifier le ou les chamlps (field) concernés par la clef -->
    <xsd:field xpath="expression xpath utlisée pour cibler le oules champs concernés par la clef" />
 </xsd:key>

 <!-- avec le xml suivant -->
 <famille>
    <membre id="m-01" parent="" />
    <membre id="m-02" parent="m-01" />
    <membre id="m-03" parent="m-01" />
    <membre id="m-04" parent="m-02" />
    <membre id="m-05" parent="m-02" />
 </famille>

 <!-- avec key et keyref -->
 <!-- création de la clef du membre de la famille-->
 <xsd:key name="membreId">
    <!-- localisation de la balise avec xpath en chemin absolu (le xpath démarre depuis la racine de l'arbre xml) -->
    <xsd:selector xpath="/membre" />
    <!-- quel est l'attribut associé à la clef -->
    <xsd:field xpath="@id" />
    <!-- @id est le raccourci de l'écriture xpath attribute::id -->
 </xsd:key>

 <!-- création de la clef parent des membres de la famille -->
 <xsd:key name="parentId">
    <!-- localisation de la balise avec xpath en chemin absolu (le xpath démarre depuis la racine de l'arbre xml) -->
    <xsd:selector xpath="/membre" />
    <!-- quel est l'attribut associé à la clef -->
    <xsd:field xpath="@parent" />
    <!-- @parent est le raccourci de l'écriture xpath attribute::parent -->
 </xsd:key>

 <!-- faire le lien entre la clef parentId et la clef membreId -->
 <xsd:keyref name="parentIdRef" refer="membreId">
    <!-- on indique la balise qui utilisera la référence -->
    <xsd:selector xpath="/membre" />
    <!-- cibler l'attribut de la balise membre qui référence une balise mebre en tant que parent -->
    <xsd:fiels xpath="@parent" />
 </xsd:keyref>

 <agenda>
     <personne>
        <client idContact="1"></client>
        <client idContact="2"></client>
        <client idContact="3"></client>
     </personne>
     <adresses>
        <adresse contact="1"></adresse>
        <adresse contact="1"></adresse>
        <adresse contact="2"></adresse>
        <adresse contact="3"></adresse>
     </adresses>
 </agenda>

 <xsd:key name="clientId">
    <xsd:selector xpath="/personne/client" />
    <xsd:field xpath="@idContact" />
 </xsd:key>
 
 <xsd:key name="adrContact">
    <xsd:selector xpath="/adresses/adresse" />
    <xsd:field xpath="@contact" />
 </xsd:key>

 <xsd:keyref name="clientAdrId" refer="clientId">
    <xsd:selector xpath="/personne/adresse" />
    <xsd:fiels xpath="@contact" />
 </xsd:keyref>
