<!-- 
    L'espace de nom donne un contexte à un terme, par exemple certains mots ont plusieurs définitions, 
    c'est le contexte dans lequel on utilise ce mot qui donne sa "fonction / définition" finale

    On peut par exemple associer le document à l’espace de nom XHTML et par soucis de praticité 
    on va utiliser le préfixe html (faciliter la lecture humaine du document) 
    car il faut savoir qu’à la base le choix du préfixe est totalement arbitraire.
-->

<html:html xmlns:html="http://www.w3.org/1999/xhtml">
    <html:head>

    </html:head>
    <html:body>
        <!-- du contenu html -->
    </html:body>
</html:html>

<!-- 
    on a vu qu'il était possible de déclarer plusieurs espaces de noms pour un même document
-->

<html:html xmlns:html="http://www.w3.org/1999/xhtml" 
    xmlns:mml="http://www.w3.org/1998/Math/MathML">
    <html:head>
        <html:title>Les espaces de noms</html:title>
    </html:head>
    <html:body>
        <!-- du contenu html -->
        <mml:math>
            <mml:apply>
                <mml:eq>
                    <!-- l'équation en question -->
                </mml:eq>
            </mml:apply>
        </mml:math>
    </html:body>
</html:html>

<!-- 
    on peut limiter la portée de la déclaration d'un espace de nom, 
    pour la déclaration multiple, 
    il est possible aussi de n'utilisier ( d'appeler ) un espace de nom seulement quand il est requis
-->
<!-- ici, on utilise le dialecte HTML -->
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Les espaces de noms</title>
    </head>
    <body>
        <!-- du contenu html -->
        <!-- à partir de cette balise, elle et tout ce qu'elle contyient utilise le dialect math -->
        <math xmlns="http://www.w3.org/1998/Math/MathML">
            <apply>
                <eq>
                    <!-- l'équation en question -->
                </eq>
            </apply>
        </math>
        <!-- on est "sorti" de la portée du vocabulaire math, on reviens dans le vocabulaire html -->
    </body>
</html>

<!-- 
    Mais comment faire si les balises que je doit utiliser à l'intérieur du vocabulaire HTML n'ont pas de namespace ?
    il est en fait possible "d'annuler" un namespace de la même façon que l'on a appelé math dans un contexte html
-->

<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>Les espaces de noms</title>
    </head>
    <body>
        <!-- du contenu html -->
        <!-- à partir de cette balise, on écrit notre propre dialecte, sans vocabulaire référent -->
        <personnage xmlns="">
            <nom>Lagaffe</nom>
            <prenom>Gaston</prenom>
        </personnage>
        <!-- on est "sorti" de la portée du "pas de vocabulaire", on reviens dans le vocabulaire html -->
    </body>
</html>

<!-- 
XML
    http://www.w3.org/XML/1998/namespace 
XInclude
    http://www.w3.org/2001/XInclude 
XLink
    http://www.w3.org/1999/xlink 
MathML
    http://www.w3.org/1998/Math/MathML 
XHTML
    http://www.w3.org/1999/xhtml 
SVG
    http://www.w3.org/2000/svg 
Schémas
    http://www.w3.org/2001/XMLSchema 
Instances de schémas
    http://www.w3.org/2001/XMLSchema-instance 
Schematron
    http://purl.oclc.org/dsdl/schematron 
XSLT
    http://www.w3.org/1999/XSL/Transform 
XSL-FO
    http://www.w3.org/1999/XSL/Format 
DocBook
    https://tdg.docbook.org/tdg/5.1/ 
Dublin Core
    https://www.dublincore.org/specifications/dublin-core/dcmi-terms/ 


-->

<!-- 
    Les DTD : Document Type Definition

    Fichiers de définition permettant de définir une structure stricte aux documents XML

    Ce sont des règles qui permettent de définir la façon dont le document doit être écrit, 
    si des balisesdoivent absolument être présentes ou imposer le type d'un donnée.

    Quand un xml est soumis à des DTD, il faut vérifier qu'il est valide => conforme aux DTD

    Les DTDT imposent donc des normes d'écritures, utiles quand un document est écrit par 
    plusieurs personnes et pour pouvoir comprendre comment l'exploiter.

-->

<!-- DTD -->

<!-- Balise contenant une autre balise -->
<contact>
    <nom>Durand</nom>
</contact>
<!--  pour contact -->
<!ELEMENT contact (nom)>

<!-- pour nom -->
<!ELEMENT nom (#PCDATA)>

<!-- si la balise nom est vide -->
<!ELEMENT nom EMPTY>
<element /> ou <element></element>

<!-- si la balise peut être vide ou remplie -->
<!ELEMENT nom ANY>

<element></element>
<!-- ou -->
<element><balise /></element>
<!-- ou -->
<element>texte</element>
<!-- ou -->
<element>texte<balise /></element>
<!-- ou -->
<element><balise />texte</element>

<contact>
    <nom>Durand</nom>
    <prenom>Jacques</prenom>
    <age>49</age>
</contact>
<contact>
    <nom>ACME Inc.</nom>
    <prenom></prenom>
    <age></age>
</contact>

<!ELEMENT contact (nom, prenom, age)>
    <!ELEMENT nom (#PCDATA)>
    <!ELEMENT prenom (#PCDATA)>
    <!ELEMENT age (#PCDATA)>

<!-- ici, la balise contact DOIT avoir un e balise nom, prenom et age -->

Balise optionnelle
<!ELEMENT contact (nom, prenom?, age)>
<!-- ici, la balise contact DOIT avoir une balise nom et age, la balise prenom n'est pas obligatoire. -->

<!-- Balise optionnelle répétée -->

<adresses>
    <adresse />
    <adresse />
    <adresse />
</adresses>

<!ELEMENT adresses (adresse*)>

<!-- Balise obligatoire qui peut être répétée plusieurs fois -->
<emails>
    <email></email> <!-- au moins une balise email obligatoire -->
    <email></email> <!-- il peut y avoir plusieurs emails -->
</emails>

<!ELEMENT emails (email+)>

<contacts>
    <contact>
        <nom>Durand</nom>
        <prenom>Jacques</prenom>
        <prenom>Antoine</prenom>
        <age>49</age>
    </contact>
    <contact>
        <nom>ACME Inc.</nom>
    </contact>
</contacts>

<!ELEMENT contacts (contact*)>
    <!ELEMENT contact (nom, prenom*, age?)>
        <!ELEMENT nom (#PCDATA)>
        <!ELEMENT prenom (#PCDATA)>
        <!ELEMENT age (#PCDATA)>

<!-- les attributs des balises en DTD -->
<!ELEMENT balise (contenu)>
    <!ATTLIST balise attr>

<!-- attribut identifiant unique obligatoire -->
<contact numero="REF-001"></contact>

<!ELEMENT contact ANY>
    <!ATTLIST contact numero ID #REQUIRED>

<!-- 
    Propriété de présence des attributs
    forme               signification
    #IMPLIED            Attribut facultatif
    #REQUIRED           Attribut obligatoire
    #FIXED valeur       Attribut avec cette valeur, non modifiable
    "valeur"            Attribut avec cette valeur par défaut mais modifiable
-->

<!-- attribut qui fait référence à un attribut référence de valeur unique -->
<!-- je ne fait que les parties contact et adresses -->

<!ELEMENT contact ANY>
    <!ATTLIST contact personne (physique|morale) "physique">
    <!ATTLIST contact numero ID #REQUIRED>
<!ELEMENT adresse ANY>
    <!ATTLIST adresse type (facturation|livraison) "facturation">
    <!ATTLIST adresse personne IDREF #REQUIRED>


<annuaire>
    <contacts>
        <contact personne="physique" numero="REF-001" />
        <contact personne="morale" numero="REF-002" />
        <contact personne="physique" numero="REF-003" />
    </contacts>
    <adresses>
        <adresse type="facturation" personne="REF-001" />
        <adresse type="livraison" personne="REF-001" />
        <adresse type="livraison" personne="REF-001" />
        <adresse type="facturation" personne="REF-002" />
    </adresses>
</annuaire>

<!-- IDREFS = plusieurs éléménets font référence au même ID -->
<artiste name="Korn" artisteId="K-0001" />
<artiste name="Ice Cube" artisteId="IC-0002" />
<artiste name="Incubus" artisteId="I-0003" />
<artiste name="Limp Bizkit" artisteId="LB-0004" />
<album name="Follow the leader" albumArtisteId="K-0001" />
<album name="Family values tour" albumArtisteId="K-0001 IC-0002 I-0003 LB-0004" />

<!ELEMENT artiste EMPTY>
    <!ATTLIST artist name CDATA #REQUIRED>
    <!ATTLIST artist artisteId ID #REQUIRED>
<!ELEMENT album EMPTY>
    <!ATTLIST album name CDATA #REQUIRED>
    <!ATTLIST album albumArtisteId IDREFS #IMPLIED>


<!-- 
    La valeur d'un attribut est une constante 
    La valeur de cet attribut, si renseigné, doit être de la valeur indiquée
-->
<!ELEMENT prix (#PCDATA)>
    <!ATTLIST prix devise CDATA #FIXED "euro">

<!-- élément valide -->
<prix devise="euro">12</prix>
<!-- élément valide car par défaut on utilise euro -->
<prix>12</prix>
<!-- invalide car USD <=> euro -->
<prix devise="USD">12</prix>

<!-- 
    Les entités
    Se sont des alias qui permettent de réutiliser des informations dans le document xml OU dans les DTD
        - générales
        - paramètres
        - externes
-->

<!ENTITY dacia "Dacia">
<!ENTITY renault "Renault">
<!ENTITY citroen "Citroën">

<voiture>
    <marque>&dacia;</marque>
</voiture>
<voiture>
    <marque>&renault;</marque>
</voiture>
<voiture>
    <marque>&citroen;</marque>
</voiture>

<!-- le xml doit se comprendre de la façon suivante -->

<voiture>
    <marque>Dacia</marque>
</voiture>
<voiture>
    <marque>Renault</marque>
</voiture>
<voiture>
    <marque>Citroën</marque>
</voiture>

<!-- 
    Entité paramètre
    N'apparaît QUE DANS LES DTD
    Elles associent un alias à une partie de déclaration de DTD 
    (une partie qui est souvent ré-utilisée ou très longue et qui la lecture du DTD compliquée)
-->

<voiture marque="Dacia" />
<voiture marque="Renault" />
<voiture marque="Citroën" />

<!-- DTD classique pour l'attribut marque -->
<!ATTLIST voiture marque (Dacia|Renault|Citroën) #REQUIRED >

<!-- Avec l'entité paramètre -->
<!ENTITY % listeMarques "marque (Dacia|Renault|Citroën) #REQUIRED">
<!ATTLIST voiture %listeMarques>

<!-- autre exemple -->
<!ELEMENT contact (nom?, prenom?, login) >
<!ELEMENT personnage (nom?, prenom?, role) >

<!-- avec les entités paramètres -->
<!ENTITY % identite "nom?, prenom?">
<!ELEMENT contact (%identite, login) >
<!ELEMENT personnage (%identite, role) >

<!-- 
    Les entités externes
    Permettent de faire référence, comme les entités générales, à des information a utiliser dans le document xml,
    mais elles sont écritent dans un ficher externe
-->

<!-- déclaration des entités externe -->
<!ENTITY dacia SYSTEM "dacia.xml">
<!ENTITY renault SYSTEM "renault.xml">
<!ENTITY citroen SYSTEM "citroen.xml">

<!-- utilisation des entités externes dans le xml -->
<voiture>
    %dacia;
</voiture>
<voiture>
    %renault;
</voiture>
<voiture>
    %citroen;
</voiture>

<!-- dacia.xml -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE description [
    <!ELEMENT description (marque, modele, portes)>
        <!ELEMENT marque (#PCDATA)>
        <!ELEMENT modele (#PCDATA)>
        <!ELEMENT portes (#PCDATA)>
]>
<description>
    <marque>
        Dacia
    </marque>
    <modele>
        Sandero
    </modele>
    <portes>
        5
    </portes>
</description>

<!-- 
    Autre schéma de validation XML : XSD (Xml Schema Definition)
    Pourquoi ?
    1 - Les DTD ne sont pas au format XML, c'est un autre language avec sa propre syntaxe et ses règles/
        => Il faut l'utiliser avec XML et il se peut que certaines API vont lire le XML et le DTD différemment.
    2 - On ne peut pas typer les données en DTD (typer une donnée : dire que la donnée dans l'attribut ou l'élément correspond à un type,
        ex :    12 => entier
                12.5 => nombre à virgule flottante
                toto => chaîne de caractère
    
    Les xsd permet de typer les données, il est aussi plus précis sur l'écriture de contraintes 
    (présence d'un élément ou d'un attribut, séquence d'élément, ordre précis ou non d'éléments dans une balise, etc)

    Il s'écrit en xml, il se stocke dans un fichier externe avec l'extension .xsd, et il utilise comme les fichiers.xml 
    un prologue dont le nom de l'élément racine est imposé
-->

<!-- prologue et déclaration d'un élément racine .xsd -->
<?xml version="1.0" encoding="UTF-8" ?>
<!-- déclaration de l'élément racine imposé du xsd-->
<xsd:schema xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    <!-- le schéma xsd du document -->
</xsd:schema>

<!-- ici on a déclaré un espace de nom pour le schéma (xsd) donc tous les éléments seront préfixé xsd: -->

<!-- le fichier xml qui va utiliser le xsd peut appeler les xsd avec ou sans espace -->

<!-- fichier xml utilisant un xsd ne décrivant pas d'espace de nom -->
<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<agenda xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="agenda.xsd">
    <!-- on crée un ns pour pourvoir appeler un schéma qui va définir tout l'agenda -->
    <rolodex>
        <nom>Durant</nom>
    </rolodex>
    <garage>
        <voiture>
            <marque>Opel</marque>
        </voiture>
    </garage>
</agenda>

<!-- fichier xml utilisant un xsd décrivant un espace de nom -->
<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<agenda 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xsi:schemaLocation="urn:Rolodex rolodex.xsd" 
    xsi:schemaLocation="urn:Garage garage.xsd" >
    <!-- on crée un ns pour pourvoir appeler plusieurs schémas pour décrire différentes partie de l'agenda -->
    <Rolodex:rolodex>
        <Rolodex:nom>Durant</Rolodex:nom>
    </Rolodex:rolodex>
    <Garage:garage>
        <Garage:voiture>
            <Garage:marque>Opel</Garage:marque>
        </Garage:voiture>
    </Garage:garage>
</agenda>

<!-- 
    le fichier au dessus a récupéré à la fois 
        - les données de rolodex, dont le schéma est défini dans rolodex.xsd  
        - les données de garage, , dont le schéma est défini dans garage.xsd 

    on a donc besoin dans le xml d'un namespace de schéma pour associer 
    les différentes parties du xml aux schémas de vérification de chaque partie
-->

<!-- 
    en dessous, pour chaque xml (rolodex et garage) on extrait chaque partie à part, 
    chacune ayant son xsd, donc pas besoin de décrire un espace de nom pour 
    le xsd a appliquer à chaque partie 
-->

<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<agenda 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xsi:noNamespaceSchemaLocation="rolodex.xsd">
    <!-- on crée un ns pour pourvoir appeler plusieurs schémas pour décrire différentes partie de l'agenda -->
    <rolodex>
        <nom>Durant</nom>
    </rolodex>
</agenda>

<?xml version="1.0" encoding="UTF-8" standalone="no" ?>
<agenda 
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
    xsi:noNamespaceSchemaLocation="garage.xsd" >
    <!-- on crée un ns pour pourvoir appeler plusieurs schémas pour décrire différentes partie de l'agenda -->
    <garage>
        <voiture>
            <marque>Opel</marque>
        </voiture>
    </garage>
</agenda>

<!-- 
    Déclaration des éléments en xsd 

    Élément simple : 
    une balise, sans attribut, ne contenant pas d'autres balises, dont le type de donnée contenu est simple.

    Élément complexe :
    une balise qui contient d'autres balises, ou dont le type de donnée contenu est complexe, ou qui possède au moins un attribut.
-->

<!-- ni attribut, nit élément, type de donnée simple => élément simple -->
<nom>Durand</nom>

<!-- Contient un attribut mais type de donnée simple : élément complexe -->
<personne type="physique">Jean Durand</personne>

<!-- contient d'autres balises -->
<!-- personne : élément complexe -->
<personne type="physique">
    <!-- nom et prenom : éléments simples -->
    <nom>Durand</nom>
    <prenom>Jean</prenom>
</personne>

<!-- 
    Déclarer un élément simple
    <namespace:element (avec le namespace définit pour le schéma) name="nom de l'élément" type="le type de la donnée contenue dans l'élément" />
    <xsd:element name="" type="" />
-->
<nom>Durand</nom>
<prenom>Jean</prenom>
<age>43</age>

<!-- en xsd -->
<xsd:element name="nom" type="xsd:string" />
<xsd:element name="prenom" type="xsd:string" />
<xsd:element name="age" type="xsd:integer" />

<!-- 
    Quelques types simple et leur définitions
    xsd:string  : chaîne de caractère "monsieur untel" "2d" "205"
    xsd:decimal : nombre à virgule flottante "12.5" "3.14168"
    xsd:integer : nombre entier "-2" "0" "12" "65535"
    xsd:boolean : booléen => vrai ou faux true or false
    xsd:date    : une date AAAA-MM-JJ ex 2023-11-28
    xsd:time    : une heure hh:mm:ss ex 13:55:22
-->

<!-- mettre une valeur par défaut -->
<xsd:element name="nom" type="xsd:string" default="Doe" />
<xsd:element name="prenom" type="xsd:string" default="John" />
<xsd:element name="age" type="xsd:integer" />

<!-- exemple de xml validés par ce schéma -->
<!-- validé -->
<nom>Durand</nom>
<prenom>Jean</prenom>
<age>43</age>

<!-- validé -->
<nom></nom> <!-- valeur par défaut "Doe" -->
<prenom>Jean</prenom>
<age>43</age>

<!-- validé -->
<nom>Durand</nom>
<prenom></prenom> <!-- valeur par défaut "John" -->
<age>43</age>

<!-- validé -->
<nom></nom> <!-- valeur par défaut "Doe" -->
<prenom></prenom> <!-- valeur par défaut "John" -->
<age>43</age>
<!-- valide -->
<nom></nom> <!-- valeur par défaut "Doe" -->
<prenom></prenom> <!-- valeur par défaut "John" -->
<age></age> <!-- pas de valeur par défaut, mais comme il n'est pas indiqué comme obligatoire, le xml est valide -->

<!--
    Valeur constante 
    valeur inchangeable, imposée et non valide si la balise est vide
-->

<xsd:element name="status" type="xsd:string" fixed="Employé·e" />
<!-- valide -->
<status>Employé·e</status>
<!-- invalide car donnée <=> Employé·e-->
<status>Junior</status>
<!-- invalide car donnée vide -->
<status></status>

<!-- 
    Les attributs

    Se sont par essence des éléments simple, pour les déclarer le mot clef c'est attribute
    <xsd:attribute  name="nom de l'attribut" type="type de l'attribut" />
 -->

<personne type="physique"></personne>

<!-- attribut type :  -->
<xsd:attribute name="type" type="xsd:string" />

<!-- ATTENTION, on déclare normalement cet attribut dans la déclaration de l'élement qui le contient, qui est lui un élément complexe -->

<!-- valeur par défaut, constante, et obligatoire -->
<!-- par défault -->
<xsd:attribute name="type" type="xsd:string" default="physique" />

<!-- constante -->
<!-- attribut devise -->
<xsd:attribute name="devise" type="xsd:string" fixed="euro" />

<!-- valide -->
<prix devise="euro">12.5</prix>

<!-- valide -->
<prix devise="">12.5</prix>

<!-- invalide -->
<prix devise="USD">12.5</prix>

<!-- obligatoire -->
<xsd:attribute name="devise" type="xsd:string" use="required" />



<!-- Quelques exemple d'éléments et d'attributs avec des types différents -->
<!-- string : chaîne de caractère -->
<xsd:element name="string" type="xsd:string" />
<string>Karamasov</string>
<string>Une phrase choc</string>
<!-- 
    certains caractère spéciaux doivent être écrit avec leur notation HTML 
    & devra s'écrire en donnée &amp;
-->
<string>Tintin &amp; Milou "Les copains" &lt;toto&gt; </string>
<!-- '&' => &amp; '<' => &lt; '>' => &gt;  -->

<string>toto</string>
<string>
    toto, 
    c'est le meilleur
</string>

<!-- language -->
<xsd:element name="langue" type="xsd:language" />
<!-- 
    norme de l'écriture d'un type language
    les deux lettres du code langue basé sur la norme ISO 639
    peut être complété par les deux lettre du code pays selon la norme ISO 3166
    xx (code langue en minsucule)
    xx-YY (YY :  code pays en majuscule)
 -->

 <langue>fr-CA</langue>
 <langue>fr-FR</langue>
 <langue>en</langue>
 <langue>en-US</langue>
 <langue>en-GB</langue>
 <langue>en-CA</langue>

<!-- 
    nmtoken string sans espace au début et à la fin, sans tabulation, sans retour chariot, sans saut de ligne
    caractères spéciaux acceptés : 
        . - _ et :
    utilisé uniquement pour les attributs
-->
<xsd:attribute name="myToken" type="xsd:NMTOKEN" />
<balise myToken="A:B_b-2.3">Contenu de ma balise</balise>
<balise myToken="AZERTY">Contenu de ma balise</balise>
<balise myToken="123456">Contenu de ma balise</balise>

<!-- invalide : il y a un espace après le dernier caracrtère de la valeur de l'attribut <> type nmtoken -->
<balise myToken="123456 ">Contenu de ma balise</balise>

<!-- 
    nmtokens : liste de nmtoken, séparés par un espace, même caractères spéciaux acceptés que nmtoken 
    et uniquement utilisable dans les attributs
 -->

<xsd:attribute name="myTokens" type="xsd:NMTOKENS" />
<balise myTokens="A:B_b-2.3">Contenu de ma balise</balise>
<balise myTokens="A:B_b-2.3 AZERTY">Contenu de ma balise</balise>
<balise myTokens="AZERTY 123456">Contenu de ma balise</balise>
<balise myTokens="A:B_b-2.3 AZERTY 123456">Contenu de ma balise</balise>

<!-- invalide : il y a un espace avant le premier caracrtère de la valeur de l'attribut <> type nmtokens -->
<balise myTokens=" AZERTY 123456">Contenu de ma balise</balise>

<!-- ID et IDREF -->
<xsd:attribute name="num" type="xsd:ID" />
<xsd:attribute name="parent" type="xsd:IDREF" />
<personne num="P1">Paul</personne>
<personne num="P2">JP</personne>
<personne num="P3" parent="P1">Martin</personne>
<personne num="P4" parent="P2">Camille</personne>

<!-- ID et IDREFS -->

<xsd:attribute name="num" type="xsd:ID" />
<xsd:attribute name="parents" type="xsd:IDREFS" />
<personne num="P1" parents="">Paul</personne>
<personne num="P2" parents="">JP</personne>
<personne num="P3" parents="">Marie</personne>
<personne num="P4" parents="">Julie</personne>

<personne num="P5" parents="P1 P3">Martin</personne>
<personne num="P6" parents="P1 P3">Camille</personne>
<personne num="P7" parents="P2 P4">Zélie</personne>
<personne num="P8" parents="P2 P4">Abraham</personne>

<!--
    Entity
    Entity permet de référencer des éléments entités, souvent non xml, qui sont déclarés dans des dtd (soit fichier.dtd soit doctype dtd directement dans le fichier xml)
    Ne s'utilise que dans les attributs
 -->

 <!-- .xsd -->
<xsd:attribute name="marque" type="xsd:ENTITY" />
 <!-- .dtd -->
<!ENTITY samsung "Samsung">
<!ENTITY apple "Apple">
 <!-- .xml -->
 <telephone marque="samsung">Galaxy SII</samsung>
 <telephone marque="apple">Iphone 254</samsung>

<!-- ENTITIES -->
 <!-- .xsd -->
 <xsd:attribute name="marque" type="xsd:ENTITIES" />
 <!-- .dtd -->
<!ENTITY samsung "Samsung">
<!ENTITY apple "Apple">
 <!-- .xml -->
 <telephone marque="samsung apple" />

 <!-- Décrire un élément complexe -->